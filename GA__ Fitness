class GA:

    fitness_levels = []
    def fitness():
        GA.fitness_levels = []
        #this is resetting the fitness levels list -- in other words, a new generation (period) has started in our simulation
        
        for i in range(world.pool):
            fit = (1300 - 260 * (schedule.individual_price_observations[i] - (schedule.price_star() / world.pool)) ** 2)
            # this is encoding a fitness level for every member of our firms by using their individual price forecasts in time t
            # note, I am not sure that schedule.individual_price_observations IS their price in time t, but it seems reasonable.
                       
            if fit > 0:
                GA.fitness_levels.append(fit)
            elif fit < 0:
                GA.fitness_levels.append(0)
                
            # this code truncates to 0 if the fitness is below 0 since anything below 0 has no meaning in probability
            # and these fitness levels will be used to generate the probability of a firm carrying on its genes
            
        return print("[",GA.fitness_levels,"]")
        
        # printing this for error checks, this part looks good!
        

    def sum_fitness():
        total = 0
        for i in GA.fitness_levels:
            total += i
        return total
        
    # this does not necessarily need its own function as it could work effectively within the check_fitness function below
    # however, I have been working on this in pieces to make it easier to code. This just sums up our previously generated fitness levels
    # the purpose is to generate probabilities of f/sum(f), where this function is sum(f)

    def check_fitness():
        GA.roulette = []
        # resetting our roulette wheel as a new generation has begun
        
        try:
            for i in GA.fitness_levels:
                percentage = i / GA.sum_fitness()
                GA.roulette.append(percentage)
        # repopulating our roulette wheel

        except ZeroDivisionError:
            pass
        # necessary for error checking if sum_fitness is 0
        
        return True

    def reproduction():
        new_firm = []
        # generating a firm list to eventually replace the previous generations firms
        
        for i in GA.roulette:
            x = np.array(GA.roulette)
            
            # turning GA.roulette into an array to solve a random.choice problem that is encountered with lists
            
            selection = random.choice(range(x.size))
            # this just looks at the probabilities generated by check fitness and picks a number from that list
            # print(selection)
            
            new_firm.append(GA.firm[selection])
            
            #appending new_firm with the selected indices of the selection choice
            # in other words, this populates that firm list with the best candidates from previous generations
            
        GA.firm = []
        # clearing the old firm list now that we no longer have a use for the previous generations firms
        
        for i in new_firm:
            GA.firm.append(i)
            # repopulating the firm list with the new generation
            
        return True
